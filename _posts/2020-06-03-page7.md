---
title: Http Message Converter
tags: spring core http request response
key: ANT 기초
---

# Message Converter ?

이번 포스팅은 스프링의 핵심 기능중 하나인 **메시지 컨버터(Message Converter)**에 관하여 다루어 보도록 하겠습니다.

메시지 컨버터는 서버로 들어 오는 데이터를 오브젝트로 가공하거나 비즈니스단에서 처리 된 오브젝트를 http 메시지로 변환하는 역활을 담당하고 있습니다.

쉽게 그림으로 표현하면 아래와 같습니다.

![ ](https://github.com/kim0lil/skfactory.github.io/blob/master/screenshots/2020/06/03/img000001.png?raw=true)

스프링에서는 **@EnableWebMvc**어노테이션을 사용하여 4가지의 기본 메시지 컨버터들을 등록할 수 있게 되어 있습니다.

아래는 그 코드들 중 하나입니다.

**WebMvcConfigurationSupport 클래스 중에서**

{% highlight java %}
protected final void addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
    messageConverters.add(new ByteArrayHttpMessageConverter());
    messageConverters.add(new StringHttpMessageConverter());
    messageConverters.add(new ResourceHttpMessageConverter());
    messageConverters.add(new ResourceRegionHttpMessageConverter());
    ...
}
{% endhighlight %}

1. ByteArrayHttpMessageConverter : byte[]을 읽고 쓰는 메시지 컨버터
2. StringHttpMessageConverter : String을 읽고 쓰는 메시지 컨버터
3. ResourceHttpMessageConverter : interface Resource을 읽고 쓰는 메시지 컨버터
4. ResourceRegionHttpMessageConverter : interface ResourceRegion을 읽고 쓰는 메시지 컨버터

또한 Gson, Atom, Rss, Jackson, xml과 같은 규격을 의존성에 등록 할 경우 스프링에서는 이와 같은 변화를 감지하여 각 메시지 컨버터를 등록 하도록 하고 있습니다.

{% highlight java %}

public class WebMvcConfigurationSupport {

	private static final boolean romePresent;

	private static final boolean jaxb2Present;

	private static final boolean jackson2Present;

	private static final boolean jackson2XmlPresent;

	private static final boolean jackson2SmilePresent;

	private static final boolean jackson2CborPresent;

	private static final boolean gsonPresent;

	private static final boolean jsonbPresent;

	static {
		ClassLoader classLoader = WebMvcConfigurationSupport.class.getClassLoader();
		romePresent = ClassUtils.isPresent("com.rometools.rome.feed.WireFeed", classLoader);
		jaxb2Present = ClassUtils.isPresent("javax.xml.bind.Binder", classLoader);
		jackson2Present = ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&
				ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", classLoader);
		jackson2XmlPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", classLoader);
		jackson2SmilePresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);
		jackson2CborPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.cbor.CBORFactory", classLoader);
		gsonPresent = ClassUtils.isPresent("com.google.gson.Gson", classLoader);
		jsonbPresent = ClassUtils.isPresent("javax.json.bind.Jsonb", classLoader);
	}

    // ..

    protected final void addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {

        // ..

		if (jackson2XmlPresent) {
			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();
			if (this.applicationContext != null) {
				builder.applicationContext(this.applicationContext);
			}
			messageConverters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));
		}
		else if (jaxb2Present) {
			messageConverters.add(new Jaxb2RootElementHttpMessageConverter());
		}

		if (jackson2Present) {
			Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.json();
			if (this.applicationContext != null) {
				builder.applicationContext(this.applicationContext);
			}
			messageConverters.add(new MappingJackson2HttpMessageConverter(builder.build()));
		}
		else if (gsonPresent) {
			messageConverters.add(new GsonHttpMessageConverter());
		}
		else if (jsonbPresent) {
			messageConverters.add(new JsonbHttpMessageConverter());
		}

        // ..
    }

    // ..
}
{% endhighlight %}

그럼 기본적으로 메시지 컨버터의 관련된 내용은 끝났습니다.

다음은 직접 메시지 컨버터를 만들어 보면서 실제적으로 메시지 컨버터가 동작하는 원리와 순서를 알아 보도록 하겠습니다.

## Restful을 활용한 ToDo List Management Api 만들기

우리의 최종 결과물은 inmemory를 저장소를 활용하여 Todo list management api를 만들어 보도록 하겠습니다.

### 준비

**Todo List**라면 당연히 **Todo** 객체와 **Todo List**객체가 있어야 할것입니다.

먼저 도메인을 하나 작성하겠습니다.

우리의 핵심 도메인인 **Todo** 클래스는 *번호*, *날자*, *할일*, *상태* 정도의 속성을 가지고 있으며 상태는 WAIT(대기), COMPLITE(완료)인 롤을 만들어 두겠습니다.

{% highlight java %}
public class Todo {
	
    // getter/setter

	enum TodoStatus {

		WAIT(1),
		COMPLITE(2);

		private int status;

		TodoStatus(int status) {
			this.status = status;
		}

		public static TodoStatus value(int status) {

			switch(status) {
				case 1 : return WAIT;
				case 2 : return COMPLITE;
			}

			return null;
		}
		
		public int valueof() {
			return this.status;
		}
		
		public boolean equals(int arg) {
			return this.status == arg;
		}
	}

	private BigInteger todoId;
	private Date todoDate;
	private TodoStatus todoStatus;
	private String todoContents;
}
{% endhighlight %}

다음으로는 내부 저장소를 만들겠습니다.

내부 저장소는 쓰레드의 안전성을 보장하는 ConcurrentMap(동시성 활용을 위한 맵 - ConcurrentHashMap)을 활용할 것입니다.

{% highlight java %}
public class TodoList {
	private ConcurrentHashMap<String, Todo> repository = new ConcurrentHashMap<>();
}
{% endhighlight %}

이제 실제 내부 구현체로는 id를 사용하여 조회할 수 있는 findById와 상태를 사용하여 조회할 수 있는 findByStatus, 마지막으로 전체를 조회 하는 findAll을 구현하겠습니다.

|메서드|기능|
|findById|id를 사용하여 Todo조회|
|findByStatus|status를 사용하여 Todo조회|
|findAll|Todo 전체 조회|

{% highlight java %}
public class TodoList {
	
	public Todo findById(BigInteger todoId) {

		return repository.contains(todoId) ? repository.get(todoId) : null;
	}
	
	public List<Todo> findByStatus(int status) {
		
		return repository.values()
                         .parallelStream()
                         .filter(e->e.getTodoStatus().equals(status))
                         .collect(Collectors.toList());
	}
	
	public List<Todo> findAll(){

		return new ArrayList<Todo>(this.repository.values());
	}
	
	private ConcurrentHashMap<BigInteger, Todo> repository = new ConcurrentHashMap<>();
}
{% endhighlight %}

아직은 사용자를 등록하는 기능이 빠졌습니다.

사용자를 등록하거나 수정하는 기능을 추가해 보겠습니다.

(이번 포스팅에서 가장 많은 코드가 들어간 구간입니다.)

|메서드|기능|
|saveTodo|Todo를 등록/수정|
|deleteTodo|Todo를 삭제|
|generateKey|Todo List의 키를 반환|

{% highlight java %}
public class TodoList {

	// ..

	public boolean saveTodo(Todo... todos) {
		
		int ic = 0;
		
		BigInteger todoId;

		for(Todo todo : todos) {
			
			todoId = todo.getTodoId();
			
			if(repository.contains(todoId)) {
				Todo orgTodo = repository.get(todoId);
				
				orgTodo.setTodoContents(todo.getTodoContents());
				orgTodo.setTodoStatus(todo.getTodoStatus());
				orgTodo.setTodoDate(todo.getTodoDate());
			} else {
				
				repository.put(todo.getTodoId(), todo);
			}
			
			ic++;
		}
		
		return ic == 0 ? false : true;
	}
	
	public boolean deleteTodo(Todo... todos) {

		int ic = 0;

		BigInteger todoId;

		for(Todo todo : todos) {
			
			todoId = todo.getTodoId();
			
			if(repository.contains(todoId)) {
				repository.remove(todoId);
				ic++;
			} 
		}
		
		return ic == 0 ? false : true;
	}
	
	public synchronized BigInteger generateKey() {
		
		return genkey = this.genkey.add(BigInteger.ONE);
	}
	
	private BigInteger genkey = BigInteger.ONE; 

	// ..
}
{% endhighlight %}

이로써 기본적인 POJO 생성은 종료 하였습니다.

다음은 스프링 설정으로 들어가 보겠습니다

### 스프링 설정

먼저 부트스트랩을 위한 스프링 이벤트 리스너 클래스를 등록해 보겠습니다.

스프링 리스너의 클래스로는 **AbstractAnnotationConfigDispatcherServletInitializer**를 구현한 클래스를 말하며 

자바환경 3.0 이상일 경우 web.xml의 xml설정을 배제하여 설정할 수 있도록 되어 있습니다.

(**ApplicationConfiguration**는 바로 다음에 만들 클래스이므로 에러가 나도 당황하지 마세요)

{% highlight java %}
public class ApplicationInitializer 
	extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return null;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		return new Class[] { ApplicationConfiguration.class };
	}

	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };
	}

}
{% endhighlight %}

웹 애플리케이션 부팅 설정이 끝났으면 다음으로 **WebMvc** 설정을 해 보도록 하겠습니다.

