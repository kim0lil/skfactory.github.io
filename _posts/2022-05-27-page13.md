---
title: git
tags: git github
---
 
# 깃 교과서

## 깃과 버전 관리

이 장에서는 본격적으로 학습하기에 앞서 깃의 필요성과 특징을 간단히 알아보겠습니다.

깃의 유용성과 다양한 적용 분야를 발견할 수 있습니다.

- - -
![버전 관리란-1](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0001.png?raw=true)


![버전 관리란-2](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0002.png?raw=true)


![버전 관리란-3](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0003.png?raw=true)
- - -

### 버전관리

프로그래밍은 컴퓨터 언어로 글을 작성하는 창작 활동이라고 할 수 있습니다. 

또 프로그래밍 개발 과정은 수많은 코드를 변경하고 테스트하는 것입니다. 

지속적으로 변경되는 과정 속에서 코드는 잠시 불안정한 수정 상태와 안정된 상태를 반복합니다. 

개발자는 안정된 상태의 코드와 불안정한 상태의 코드를 인지하고, 항상 안정된 상태를 유지하도록 노력해야 합니다.

#### 버전이란

버전이란 무엇일까요? 컴퓨터 프로그램을 사용하면서 버전(version)이라는 단어를 많이 들어 보았을 것입니다. 

대부분은 윈도 10, 한글 9.7 등 프로그램 이름 뒤에 붙어 있는 숫자가 버전을 의미한다고 알고 있을 것입니다. 

맞습니다. 이 숫자가 버전입니다. 

사전을 찾아보면 이전의 것과 다른 또는 약간 비슷한 것으로 정의되어 있습니다.

버전은 이전과 약간씩 다른 변화들을 구분하는 표시입니다. 

버전을 표시하는 데 숫자를 많이 사용하지만 꼭 숫자만 사용해야 하는 것은 아닙니다. 

2016에디션, 2017에디션, 윈도 XP, macOS X 엘카피탠처럼 연도나 다른 기호를 사용하기도 합니다.

그렇다면 서브버전은 무엇일까요? 

보통 버전과 버전 사이에도 코드가 수없이 변화되며 이 중간에도 버전이 있습니다. 

이처럼 버전과 버전 사이에 변화된 것을 서브버전이라고 합니다. 

1.0 버전과 2.0 버전 사이에는 1.01, 1.02, 1.03처럼 수많은 서브버전이 있습니다.

이러한 버전의 숫자나 기호 역시 일련의 규칙들이 있습니다. 

버전을 부여하려면 소스 코드를 구별할 수 있는 의미 있는 변화가 있어야 합니다. 

개발 도중 임시로 작업한 것을 버전이라고 말하지는 않습니다.

#### 버전 관리는 왜 필요할까

어릴 적부터 많이 듣던 말 중에 **공부에는 왕도가 없다.**가 있습니다. 

마찬가지로 프로그램 코드도 한 번에 모두 완성되지 않습니다. 

일반적으로 프로그램 코드는 한 단계씩 살을 붙여 가면서 기능들을 추가해 나갑니다. 

오랜 시간 동안 수많은 작업을 개선하면서 데이터는 변하고 끊임없이 증가합니다. 

이러한 변화와 작업을 진행하면서 하나의 완성된 프로그램을 만드는 것입니다.

개발 도중에는 많은 기능이 추가되고, 수많은 코드가 변경됩니다. 

변경되는 동안 코드들은 잠시 불안정한 상태가 되고, 이후 정상적인 테스트와 동작을 확인하고 나면 다시 안정된 상태의 코드가 됩니다.

숙련된 개발자라면 작업 과정에서 코드들을 안정되게 유지해야 한다는 것을 잘 압니다. 

개발 또는 테스트하는 과정에서 불안정한 코드가 있다면 계속 이어서 작업하기 불안할 것입니다. 

때에 따라 더 이상 작업하기 어려울 수도 있습니다. 

이때는 이전 상태로 돌아가 다시 시작할 수 있는 코드의 복귀(포인트) 지점이 필요합니다.

![코드 복귀 지점](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0004.png?raw=true)

코드 복귀 지점은 반드시 안정된 코드 상태를 기준으로 설정해야 합니다. 

이렇게 복귀 지점을 기록해 두면 좀 더 자유롭고 안정적으로 개발할 수 있습니다.

### 버전 관리 시스템

우리는 컴퓨터를 사용하면서 이미 다양한 방법으로 버전을 기록하고 있습니다. 

예를 들어 워드프로세서로 보고서를 작성할 때 갑자기 컴퓨터 전원이 꺼져서 작업한 내용이 사라진 적이 있을 것입니다.

이러한 경험을 하게 되면 자신도 모르게 작업 상태를 수시로 저장하는 습관이 생깁니다. 

이처럼 작업 상태를 저장하는 것 또한 변화의 기록입니다.

일반적으로 우리는 한 파일에 계속 덮어 쓰면서 저장합니다. 

이때 변화되는 버전을 표시하지 않았기 때문에 이전 상태로는 돌아가지 못합니다. 

변화가 있는 문서 상태를 구분하고 싶을 때는 보통 `파일이름1, 파일이름2`처럼 파일 이름을 다르게 저장하곤 합니다. 

이 다른 이름으로 저장하는 방식은 한 문서를 여러 파일로 계속 저장하는 방식이라, 시간 차이를 두고 저장하다 보면 이름 규칙을 잊곤 합니다. 

다음과 같이 통일성 없이 파일 이름을 만들어 저장했다면 버전을 알아보기 힘듭니다.

![새 파일로 계속 저장](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0005.jpeg?raw=true)

그렇다면 파일 버전을 좀 더 편리하고 정확하게 관리할 수는 없을까요? 

이때 사용하는 것이 버전 관리 소프트웨어입니다. 

특히 프로그래밍 코드는 일반 문서와 달리 복잡하고 많이 변경되므로 버전 관리 소프트웨어를 사용하는 것이 좋습니다.

#### 버전 관리 소프트웨어

코드와 콘텐츠의 변화를 관리하고 추적하는 소프트웨어를 버전 관리 시스템(VCS, Version Control System)이라고 합니다. 

최초의 버전 관리 시스템은 유닉스 환경에서 사용 가능한 SCCS(Source Code Control System)입니다. 

SCCS는 1970년대 마크 로치킨드(Marc J. Rochkind)가 개발했으며, 이후 다양한 VCS 프로그램이 등장합니다. 

VCS에서 버전 파일들을 관리하고 저장하는 공간을 저장소(`repository`)(리포지터리)라고 합니다.

현재 사용하는 VCS는 크게 `집중형`과 `분산형`, 두 종류로 구분할 수 있습니다.

##### 집중형

집중형 시스템은 말 그대로 모든 소스 코드가 한곳에 집중되어 있는 형태입니다. 

하나의 메인 중앙 서버에서 개발 구성원의 모든 소스 코드를 통합적으로 관리합니다. 

`클라이언트-서버 모델`이라고도 합니다.

* 장점: 저장소 하나를 중심으로 관리하기 때문에 시스템을 운영하기 수월합니다.
* 단점: 중앙 저장 공간인 서버에 문제가 생기면, 소스 코드가 있는 메인 저장소에 모든 개발자가 접근할 수 없는 심각한 상황이 발생할 수 있습니다. 또 동시에 여러 개발자가 접근하면 충돌이 발생하기에 코드 수정을 안정적으로 할 수 있게 잠금 모델을 적용합니다. 파일을 변경하려면 개발자들은 순서대로 대기하고 있어야 합니다.

- - -

> 잠금 모델 

보통 다수의 클라이언트가 서버에 동시 접속하곤 합니다. 

파일 하나를 다수의 사용자가 동시에 접근하여 수정하려고 한다면 충돌이 발생합니다. 

누군가 먼저 파일을 수정하고 있다면 다른 사용자는 수정을 못하도록 잠금을 설정하여 방지할 수 있습니다.

- - -

대표적인 집중형 관리 시스템은 다음과 같습니다.

* SCCS : 1970년대 최초의 버전 관리
* RCS : 1980년대 정방향/역방향 개념 도입
* CVS : 1986년
* 서브버전 : 2000년

##### 분산형

분산형 버전 관리 시스템(DVCS, Distributed Version Control System)은 집중형 시스템과 달리 저장소가 여러 개 있습니다. 

여러 저장소에 각 버전별 소스를 개별 보관합니다. 

분산 저장소는 P2P(Peer-to-Peer) 방식으로 공유하며, 각 개발자에게 공유 가능한 저장소 사본을 제공합니다. 

서버는 각 저장소 자료를 동기화하고 중개하는 역할만 수행합니다. 

따라서 메인 서버에 문제가 생기더라도 지속적으로 개발할 수 있습니다. 

그 대신 익숙해지는 데 시간이 걸리는 단점이 있습니다.

대표적으로 분산형 관리 시스템은 다음과 같습니다.

* 깃(Git): 현재 가장 많이 사용하는 분산형 VCS입니다. 오픈 소스라서 무료로 사용이 가능합니다.
* 머큐리얼(Mercurial): 파이썬 언어로 개발했으며, 무료입니다. 자세한 정보는 https://www.mercurial-scm.org/에서 확인 가능합니다.
* 비트키퍼(BitKeeper): 1998년에 출시했으며, 상용(유료) 제품입니다. 자세한 정보는 http://www.bitkeeper.org/에서 확인 가능합니다.

### 깃

깃은 2005년에 리눅스 개발자인 리누스 베네딕트 토르발스(Linus Benedict Torvalds)가 개발했습니다.

깃의 모든 소스는 깃허브에 공개되어 있으며, 깃허브에서 git으로 검색하면 됩니다.

[공식 사이트](https://github.com/git/git)

![깃 사이트](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0006.jpeg?raw=true)

깃은 다음과 같이 몇 가지 특징으로 구분할 수 있습니다.

* 대표적인 분산형 버전 관리 시스템입니다. 원격 저장소(remote repository)와 별개로 개발자 각각의 로컬 컴퓨터에 완벽한(원격 저장소의 내용과 동일한) 복제본 소스 코드를 저장할 수 있습니다. 완벽한 복제본이 있으면 매번 중앙 저장소를 조회하지 않아도 개발을 진행할 수 있습니다.
* 네트워크나 인터넷이 연결되어 있지 않은 상태에서도 로컬 컴퓨터의 소스 코드만으로 버전을 관리할 수 있습니다. 작업 후 나중에 인터넷에 연결되었을 때 동기화만 하면 됩니다.
* 원격 저장소로 많은 개발자의 저장소와 연결하거나 동기화 작업을 할 수 있습니다. 또 직접 만든 새로운 소스 코드를 배포하거나 내려받은 소스 코드를 수정한 후 다시 병합(merge)할 수도 있습니다.

#### 백업 기능

분산형 깃은 자신의 로컬 컴퓨터에서 독립적으로 소스의 버전 관리를 할 수 있습니다. 

독립적이란 것은 로컬 컴퓨터에서 자체적으로 버전을 기록하고 관리할 수 있는 시스템을 의미합니다. 

혼자 진행하는 프로젝트에서는 이것만으로도 충분합니다. 

하지만 컴퓨터에 문제가 생긴다면 지금까지 개발한 모든 소스를 잃을 수 있습니다. 

이에 대비하여 별도의 외부 저장 장치에 데이터를 백업하곤 합니다. 

하지만 외부 저장 장치에 백업하는 코드는 단순히 파일을 복사하는 것으로 기존 소스 코드와는 동기화하지 않은 별개의 파일입니다. 

프로젝트 개발자라면 코드를 좀 더 안전하게 유지하고 백업하는 데 항상 신경 써야 합니다.

이때 깃을 사용하면 편리합니다. 

깃을 사용하면 코드를 원격 저장소에 저장할 수 있습니다. 

또 로컬 컴퓨터의 저장소를 동기화하여 원격 저장소에 백업합니다. 

그리고 사무실, 집 등 여러 공간에서 원격 저장소에 저장된 내용을 다시 내려받아 프로젝트 개발을 이어서 할 수 있습니다.

#### 협업 개발

깃은 다수의 개발자와 코드를 공유하고 협업할 때 매우 유용합니다.

##### 코드 공유

예전에는 팀 내에서 코드를 공유하려고 외부 저장 장치를 이용하곤 했습니다. 

이는 매우 번거로운 작업입니다. 깃을 사용하면 네트워크를 통해 코드를 좀 더 쉽게 공유할 수 있습니다. 

심지어 인터넷이 연결되지 않은 상태에서도 코드 이력을 관리하고, 다른 개발자와 공유하여 협업할 수 있습니다.

##### 책임과 기록

깃은 변경된 모든 이력을 저장합니다. 

누가 언제 어떤 파일을 수정했는지 기록하기 때문에 코드를 좀 더 책임감 있게 작성하고 유지할 수 있습니다. 

깃은 커밋(commit)을 거쳐 모든 코드의 수정 이력을 기록합니다. 

따라서 깃의 커밋은 신중하게 작업해야 합니다. 

커밋으로 저장된 원본 객체는 수정할 수 없습니다.

##### 원격 공유

분산된 여러 저장소 간에 정보를 주고받으려면 중앙 서버가 필요합니다. 

깃에서는 원격 저장소가 중앙 서버 역할을 합니다. 

자신의 코드 저장소를 원격 서버에 푸시(push)하여 저장(동기화)합니다. 

또 다른 개발자의 소스를 원격 서버에서 풀(pull) 또는 페치(fetch)하여 언제든지 내려받을 수 있습니다.

깃을 사용하면 개발 구성원 간에 소스 코드를 쉽게 주고받을 수 있습니다. 

원격 저장소로 전송된 코드는 여러 개발자와 소스 코드를 공유합니다. 

협업하여 코드를 개발할 때 공유 기능은 매우 중요합니다.

##### 병합

깃은 하나의 소스 코드를 여러 가지 브랜치로 분기하여 독립된 기능을 구현할 수 있습니다. 

독립적으로 구현된 소스를 주고받으며, 필요하다면 각 브랜치를 하나로 병합하기도 합니다. 

하지만 독립적으로 구현된 코드들을 수작업으로 병합하는 것은 어렵습니다. 

깃에서는 다양한 병합 알고리즘을 제공하기 때문에 이를 이용하여 소스 코드의 충돌을 최소화하고 최종 코드를 쉽게 유지할 수 있습니다.

##### 공개

원격 저장소를 사용하여 개발 중인 코드를 외부로 공개할 수 있습니다. 

코드를 공개함으로써 내부 개발자가 만든 기능 한계를 극복하고 외부 개발자와 협업할 수 있습니다. 

이처럼 공개된 프로젝트는 많은 개발자 간의 협력으로 프로젝트를 빠르게 성장 및 발전시킬 수 있습니다.

외부 개발자는 원격 저장소를 포크(fork)하여 소스 코드의 버그를 수정하거나 기능을 개선할 수 있습니다. 

또 수정한 소스 코드를 풀 리퀘스트(pull request)하여 기존 코드에 병합할 수도 있습니다.

### 깃의 동작 한눈에 보기

앞으로 깃의 다양한 동작을 살펴볼 것입니다. 깃은 크게 다섯 단계로 진행됩니다.

![깃의 다섯 단계](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0007.png?raw=true)

* 초기화 : 폴더를 깃 저장소로 변경합니다.
* 커밋 : 변경된 코드의 이력을 기록합니다.
* 브랜치 : 분리 격리된 코드 이력을 기록합니다.
* 병합 : 기존 이력과 분리된 이력을 통합합니다.
* 푸시 : 로컬 저장소의 이력을 서버로 전송 및 공유합니다.

### 정리

깃은 다양한 알고리즘과 기술로 무장하고 있습니다. 

또 많은 프로젝트를 깃으로 관리하면서 안정성과 가치를 인정받고 있습니다. 

깃을 잘 활용하려면 깃의 개념을 이해하고 많이 사용해 보아야 합니다. 

앞으로 장별로 제공하는 실습을 따라 하면서 여러 가지 깃의 기능을 학습할 것입니다. 

깃을 잘 활용하여 자신의 개발 능력을 한 단계 더 높일 수 있는 계기가 되었으면 합니다.

## 깃과 소스트리 설치 및 환경 설정

![깃 설치](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0008.png?raw=true)

![소스 트리 설치](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0009.png?raw=true)

### 깃 설치

깃을 사용하려면 먼저 깃 프로그램을 설치해야 합니다. 

윈도우, 리눅스, macOS 등 여러 운영 체제에서 깃을 설치하고 사용할 수 있습니다.

깃은 오픈 소스이기 때문에 공개된 소스를 직접 내려받아 설치할 수 있지만, 컴파일 작업과 설치가 쉽지 않습니다.

따라서 깃의 개발을 이끄는 단체에서는 일반 개발자도 쉽게 사용할 수 있도록 운영 체제별 설치 프로그램을 만들어 제공합니다. 

깃 공식 사이트(https://git-scm.com)에서 운영 체제별로 만든 배포판을 내려받아 설치할 수 있습니다.

![깃 공식 사이트](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0010.jpeg?raw=true)

- - -

* Note

깃의 소스 코드는 https://github.com/git/git에 모두 공개되어 있습니다. 

여기에 공개된 버전은 깃 공식 사이트에 공개된 버전보다 좀 더 최신이므로, 최신 버전을 사용하고 싶다면 깃의 소스 코드를 직접 내려받아 컴파일한 후 설치해야 합니다. 

책에서는 깃 공식 사이트에서 내려받아 사용하는 것을 추천하니 참고만 하세요. 

또 오픈 소스에도 직접 참여할 수 있습니다.

- - -

깃의 기본 작업 환경은 터미널 모드입니다. 

리눅스나 macOS 사용자라면 콘솔창 환경에 익숙할 것입니다. 

윈도우 사용자라면 콘솔창을 처음 접하는 사람도 있을 수 있습니다. 

과거 MS-DOS 시절에는 콘솔 명령어를 주로 사용했습니다. 

하지만 윈도 그래픽 운영 체제가 널리 보급되면서 콘솔창에서 작업하는 빈도가 많이 줄었습니다. 

게다가 리눅스와 윈도 계열의 콘솔 명령어는 조금 차이가 있습니다.

깃은 배시(bash) 환경을 제공합니다. 

깃 배시는 윈도, 리눅스, macOS 사용자 모두 동일한 콘솔 명령어로 작업할 수 있도록 통일된 환경을 제공합니다.

터미널 작업이란 콘솔창에서 직접 명령어를 입력하여 동작하게 하는 것입니다. 

깃을 능숙하게 다루려면 다양한 깃 명령어 사용법에 익숙해져야 합니다. 

그래서 콘솔창에서 작업하는 것은 명령어를 사용해야 하기에 초보자에게는 다소 어려운 부분이 있습니다.

#### 윈도우에서 설치

마이크로소프트의 윈도우는 전 세계적으로 가장 많이 사용하는 운영 체제입니다. 

윈도우 운영 체제에서 깃을 설치하는 방법을 알아봅시다.

깃 공식 사이트(https://git-scm.com)에 접속하여 윈도용 설치 파일을 내려받겠습니다. 

웹 사이트 오른쪽 아래에 위치한 설치 파일을 클릭하여 내려받습니다. 

설치 파일 내려받기가 완료되면 윈도의 다운로드 폴더에 저장됩니다.

![깃 설치 파일 내려받기](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0011.jpeg?raw=true)

내려받은 설치 파일을 더블클릭하여 실행합니다. 

다음과 같이 깃 설치 관리자 프로그램을 실행합니다. 

깃은 GNU 오픈 소스 라이선스 형태로 배포합니다. 

라이선스에 동의한다면 Next를 누릅니다.

![깃 설치 시작](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0012.jpeg?raw=true)

다음은 설치 경로를 설정하는 화면입니다. 

기본값은 `C:/Program Files/Git`이며, 기본값으로 설치할 것입니다. 

원하는 경로가 있다면 새로 입력합니다. 

경로를 확인한 후 Next를 누릅니다.

![설치 경로 확인](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0013.jpeg?raw=true)

깃의 설치 프로그램에는 다양한 컴포넌트가 있습니다. 

설치 과정에서 필요한 컴포넌트를 다음과 같이 선택 가능합니다. 

보통 기본 설정 값을 이용하면 무난하게 설치할 수 있습니다. 

책에서도 기본값을 사용하겠습니다. 

확인 후 Next를 누릅니다.

![컴포넌트 선택](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0014.jpeg?raw=true)

윈도에서는 유사한 응용 프로그램을 몇 개 묶어서 프로그램 메뉴 목록 형태로 관리합니다. 

깃 역시 관련 있는 실행 프로그램을 묶어서 등록합니다. 

등록 목록의 이름을 직접 지정할 수도 있지만, `Git`이란 이름이 기본값으로 설정되어 있습니다. 

기본값으로 두고 Next를 누릅니다.

![목록 이름 입력](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0015.jpeg?raw=true)

깃은 커밋 등 작업을 처리할 때 메시지를 입력합니다. 

주석 문장을 작성하거나 편집할 때는 에디터가 필요한데 깃은 별도의 외부 에디터 프로그램을 사용합니다. 

기본값으로 Vim이 선택되어 있습니다. 

다른 외부 편집기를 사용하고 싶다면 직접 지정하면 됩니다. 

기본값인 Vim으로 두고 Next를 누릅니다.

![에디터 선택](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0016.jpeg?raw=true)

- - -

Vim 에디터를 사용하려면 간단한 기본 조작법 정도는 알고 있으면 좋습니다.

•수정:

`Esc`를 누른 후 `:` + `i`

•저장:

`Esc`를 누른 후 `:` + `w`

•종료:

`Esc`를 누른 후 `:` + `q`

- - -

다음은 깃 배시 명령어를 실행할 수 있는 경로를 설정하는 화면입니다. 

기본값으로 두고 Next를 누릅니다.

![경로 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0017.jpeg?raw=true)

* Use Git from Git Bash only: 깃 배시 터미널로만 깃을 사용할 수 있습니다. 윈도의 환경 변수를 설정하지 않습니다.
* Git from the command line and also from 3rd-party software: 기본 설정 값입니다. 윈도용 cmd 창에서도 git 명령어를 사용할 수 있습니다. 윈도의 환경 변수를 추가합니다.
* Use Git and optional Unix tools from the Command Prompt: 윈도용 cmd 창에서 git과 유닉스 도구 명령어를 사용할 경우 선택합니다. 유닉스 관련 도구 옵션을 추가합니다.

깃은 SSH 프로토콜 통신을 이용하여 서버 간 코드 이력을 전송할 수 있습니다. 

다음은 SSH 프로토콜 통신과 관련된 설정을 하는 화면입니다. 

기본값으로 두고 Next를 누릅니다.

![SSH 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0018.jpeg?raw=true)

파일의 엔딩 라인(ending line)을 처리하는 방법은 운영 체제별로 약간 차이가 있습니다. 

깃은 다양한 운영 체제와 엔딩 라인을 처리할 수 있도록 선택 화면을 제공합니다. 

기본값으로 두고 Next를 누릅니다.

![엔딩 라인 처리 선택](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0019.jpeg?raw=true)

- - -

* Note

깃은 윈도와 유닉스 계열의 운영 체제를 모두 지원합니다. 

하지만 두 운영 체제는 엔딩 라인에 각각 LF(Line Feed: 유닉스/리눅스에서 사용)와 CRLF(Carriage Return Line Feed: MS-DOS/윈도에서 사용)를 사용하는데, 이 둘은 호환되지 않습니다. 

그래서 옵션을 알맞게 선택해 주어야 합니다.

- - -

다음은 터미널 에뮬레이터를 선택하는 화면입니다. 

기본값으로 두고 Next를 누릅니다.

![터미널 에뮬레이터 선택](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0020.jpeg?raw=true)

다음은 추가 옵션 화면입니다. 

기본값으로 두고 Install을 누릅니다.

![그 외 옵션들](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0021.jpeg?raw=true)

다음과 같이 설치를 진행합니다.

![설치 진행](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0022.png?raw=true)

설치가 완료되었습니다. 

Finish를 누릅니다.

![깃 설치 완료](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0023.jpeg?raw=true)

윈도 운영 체제에 깃이 정상적으로 설치되었는지 확인해 봅시다. 

윈도 버튼을 클릭하고, 프로그램 목록에서 Git을 찾습니다. 

목록 폴더에 바로가기 아이콘 3개가 추가되어 있는지 확인합니다. 

윈도용 깃은 리눅스와 동일한 명령어를 실행할 수 있도록 Git Bash(깃 배시)를 제공합니다. 

Git Bash를 선택합니다.

![윈도 메뉴의 Git](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0024.jpeg?raw=true)

Git Bash를 선택하면 다음과 같이 터미널 콘솔창을 실행합니다. 

깃의 동작 명령어는 대부분 깃 배시 콘솔창에서 실행합니다.

![깃 배시 콘솔창](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0025.jpeg?raw=true)

콘솔창을 실행하면 다음과 같이 명령 프롬프트가 실행됩니다.

```cmd
컴퓨터이름 MINGW64 ~$ 
```

깃 배시는 현재의 작업 디렉터리 경로를 표시합니다. 

처음 깃 배시를 시작하면 경로 주소 이름이 물결(`~`)로 표시됩니다. 

`~` 기호는 현재 자신의 계정 위치를 의미합니다.

리눅스 계열의 운영 체제는 명령 프롬프트 기호로 달러(`$`)를 사용합니다. 

`$` 기호는 계정 아이디로 접속했을 때를 의미합니다. 

관리자 `root`로 접속하면 `#` 기호로 표시됩니다.

#### 리눅스에서 설치

리눅스는 유닉스에서 파생된 운영 체제입니다. 

또 전 세계에서 가장 많이 운영하는 서버 환경입니다. 

클라우드와 서버용 환경을 같이 개발한다면 리눅스용 깃 환경이 필요할 것입니다.

리눅스 운영 체제에서 깃을 설치하는 방법은 간단합니다. 

대부분의 리눅스 배포판은 관련된 응용 프로그램을 패키지 형태로 제공합니다. 

패키지는 리눅스 배포판마다 약간 차이가 있습니다. 

리눅스 패키지 관리 도구를 이용하면 깃 공식 사이트에서 설치 파일을 내려받지 않고도 설치할 수 있습니다. 

또 소스 코드를 직접 내려받아 복잡한 컴파일 작업을 하지 않아도 되므로 편리합니다.

깃을 설치하려면 먼저 자신의 리눅스 배포판과 환경을 알아야 합니다. 

다음과 같이 입력하여 자신의 환경을 확인합니다.

```sh
root@host:~# cat /etc/issue
Ubuntu ... LTS \n \l
```

리눅스 배포판 서버에서 패키지를 내려받아 설치합니다. 

예를 들어 자신의 리눅스 배포판이 페도라(Fedora), CentOS 계열이라면 yum 명령어로 깃을 설치할 수 있습니다.

```sh
$ sudo yum install git
```

데비안 계열의 우분투 리눅스라면 apt 명령어를 사용합니다.

```sh
$ sudo apt install git
```

최신 리눅스 배포판은 기본적으로 설치 패키지에 깃을 포함합니다. 

따라서 별도로 설치하지 않아도 깃을 사용할 수 있습니다. 

콘솔창에서 `git –version` 명령어로 깃이 설치되었는지 확인할 수 있습니다.

```sh
root@host:~# git –version

$ git version ...
```

배포판에 설치된 깃이 오래된 버전이라면, 패키지를 삭제하고 다시 설치할 수도 있습니다. 

`remove` 옵션을 사용하여 기존에 설치된 깃을 제거할 수 있습니다.

```sh
root@hojin1:~# apt remove git

Reading package lists... Done

Building dependency tree

Reading state information... Done

...

Removing ubuntu-server (1.417.1) ...

Removing git (1:2.17.1-1ubuntu0.4) ...
```

설치된 깃을 삭제했다면, 새로운 깃 버전을 패키지 관리자로 설치하면 됩니다.

```sh
root@hojin1:~# apt install git

Reading package lists... Done

Building dependency tree

Reading state information... Done

...

Preparing to unpack .../git_1%3a2.17.1-1ubuntu0.4_amd64.deb ...

Unpacking git (1:2.17.1-1ubuntu0.4) ...

Setting up git (1:2.17.1-1ubuntu0.4) ...
```

앞 코드와 실행 결과가 비슷하다면 정상적으로 설치된 것입니다. 

원하는 특정 버전이 있다면, 깃 공식 사이트에 접속하여 설치 파일이나 소스 코드를 내려받아 컴파일하여 설치할 수도 있습니다.

#### macOS에서 설치

최근 들어 macOS 운영 체제를 개발 환경으로 사용하는 사람이 많아졌습니다. 

macOS도 유닉스와 비슷한 NextStep을 기반으로 발전된 운영 체제이기 때문에 대부분의 사용법은 리눅스와 비슷합니다. 

또 리눅스와 마찬가지로 최근 macOS 시스템에는 대부분 깃이 기본으로 설치되어 있습니다.

특정 버전의 깃을 설치하고 싶다면 깃 공식 사이트에 접속하여 macOS용 git 패키지를 내려받습니다. 

`dmg` 파일을 내려받은 후 `dmg` 파일 안에 있는 `pkg` 파일을 실행하면 깃이 설치됩니다.

### 소스트리 설치

소스트리는 아틀라시안(Atlassian)에서 배포하는 GUI 깃 도구입니다. 

소스트리를 사용하려면 기본적으로 깃을 컴퓨터에 설치해야 합니다. 

소스트리는 깃을 GUI로 사용하는 외부 도구일 뿐입니다.

소스트리는 공식 사이트에서 무료로 내려받을 수 있습니다. 

먼저 소스트리 공식 사이트(https://www.sourcetreeapp.com)에 접속합니다. 

운영 체제에 맞는 다운로드 버튼을 클릭합니다.

![소스트리 공식 사이트](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0026.jpeg?raw=true)

위 그림은 같은 화면이 나오면 라이선스에 동의한 후 `Download`를 눌러 설치 파일을 내려받습니다. 

소스트리는 윈도와 macOS용 모두 제공하므로 자신의 컴퓨터 환경에 맞는 버전을 내려받으면 됩니다. 

책은 윈도를 기반으로 설명합니다.

![라이선스 동의](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0027.jpeg?raw=true)

설치 파일을 내려받았다면 이제 소스트리를 설치하겠습니다. 

먼저 내려받은 설치 파일을 실행합니다. 

잠시 기다리면 설치 화면이 나옵니다.

![소스트리 설치 화면](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0028.jpeg?raw=true)

다음 화면이 나오면 Bitbucket 메뉴를 선택합니다.

![Bitbucket 메뉴 선택](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0029.jpeg?raw=true)

로그인 화면이 나오면 회원 가입을 하거나 로그인합니다.

![아틀라시안 웹 사이트 로그인](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0030.jpeg?raw=true)

- - -

* Note

소스트리를 사용하려면 아틀라시안 계정이 필요합니다. 

공식 사이트에서 Sign up for an account를 클릭해서 회원 가입을 할 수 있습니다. 

구글 계정 등을 연동하여 간편하게 회원 가입을 할 수도 있습니다. 

이전에 가입한 계정이 있다면 로그인합니다.

- - -

정상적으로 회원 가입 및 로그인을 완료하면 등록 완료 화면으로 전환됩니다.

![로그인 확인 중](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0031.jpeg?raw=true)

![등록 완료](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0032.jpeg?raw=true)

소스트리를 설치할 수 있는 확인 절차가 마무리되었습니다. 

다음으로 본격적인 소스트리 설치 과정을 진행합니다. 

소스트리는 깃 외에 머큐리얼(Mercurial) 같은 버전 관리를 동시에 지원합니다. 

깃만 사용한다면 Mercurial 체크는 해제합니다. 

책에서는 Mercurial 체크를 해제한 후 다음을 누릅니다.

![Mercurial 체크 해제](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0033.jpeg?raw=true)

깃을 사용하려면 환경 설정을 해야 합니다. 

먼저 깃으로 이력을 관리할 때 사용할 이름과 이메일주소를 설정합니다. 

첫 번째 항목에는 이름(영문)을 입력하고, 두 번째 항목에는 이메일 주소를 입력합니다. 

아틀라시안 계정이 기본값으로 입력되어 있으므로 그대로 사용해도 되고, 전혀 다르게 원하는 이름과 이메일 주소를 사용해도 됩니다. 

모두 입력했다면 다음을 누릅니다.

![환경 설정용 이름과 이메일 주소](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0034.jpeg?raw=true)

- - -

* Note

깃의 환경 설정 과정에서 등록하는 이름과 이메일 주소는 아틀라시안 웹 사이트에 가입한 이름 및 이메일 주소와는 상관없습니다. 

등록된 환경 설정 정보는 깃 커밋 작업을 위한 환경 정보이므로 원하는 내용으로 입력합니다.

- - -

소스트리는 깃허브, 비트버킷과 연동하여 원격 저장소(서버) 작업을 같이 수행할 수 있습니다. 

원격 저장소를 사용하려면 깃허브, 비트버킷에 로그인해야 합니다. 

또는 SSH키를 이용하여 로그인할 수도 있습니다. 

아직 아무것도 준비되어 있지 않으니 다음 화면이 나오면 일단 아니오를 눌러 넘어갑니다. 

깃허브 설정 관련 내용은 뒤편에서 다룹니다.

![SSH 키 로그인 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0035.jpeg?raw=true)

소스트리 설치가 완료되면 프로그램을 실행합니다. 

소스트리는 비트버킷에 생성된 원격 저장소 목록을 같이 나열하여 표시합니다. 

또 깃허브의 원격 저장소도 같이 사용할 수 있습니다. 

아래 그림은 샘플 화면입니다. 

깃과 소스트리를 처음 설치했다면 아무 목록도 표시하지 않습니다.

![원격 저장소 목록](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0036.jpeg?raw=true)

이제 소스트리는 잠시 두고 터미널로 돌아가겠습니다.

### 첫 번째 깃 실행

첫 실습으로 간단한 깃 명령어를 입력해서 실행 결과를 살펴보겠습니다. 깃의 기본 사용 환경은 터미널입니다.

#### 터미널

터미널 환경이란 예전의 MS-DOS 또는 셸(shell)처럼 텍스트 명령어를 입력하고 실행하는 환경을 의미합니다. 

터미널을 이용하면 깃 작업을 좀 더 다양하게 할 수 있습니다. 

GUI는 많이 사용하는 기능 위주로 동작을 구현했기 때문에 터미널보다 정밀한 작업은 하기 어렵습니다.

#### 깃 명령어로 실행

깃 프로그램 이름은 git입니다. 

터미널에서 git과 명령어를 입력하면 깃이 동작합니다. 

그냥 git이란 이름만 입력해도 실행됩니다. 

`git`이라고 입력해 보세요. 

`git` 명령어 사용법 및 간단히 요약된 내용을 볼 수 있습니다.

```sh
$ git

usage: git [–version] [–help] [-C <path>] [-c <name>=<value>]
           [–exec-path[=<path>]] [–html-path] [–man-path] [–info-path]
           [-p | –paginate | -P | –no-pager] [–no-replace-objects] [–bare]
           [–git-dir=<path>] [–work-tree=<path>] [–namespace=<name>]
           <command> [<args>]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone              Clone a repository into a new directory
   init               Create an empty Git repository or reinitialize an existing one

```

- - -

Note 환경 변수에 경로 설정

git 명령어를 입력했는데도 제대로 실행되지 않았다면, 다음과 같이 윈도의 환경 변수에 경로(`PATH`)를 추가해 주어야 합니다. 

또는 기본적으로 모든 디렉터리 경로에서 깃이 실행되도록 하고 싶을 때도 환경 변수에 경로를 설정해 줍니다.

윈도에서 제어판을 실행한 후 `시스템 > 고급 시스템 설정`을 선택하여 시스템 속성 창을 엽니다. 

`고급 > 환경 변수`를 누릅니다.

![환경 변수 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0037.jpeg?raw=true)

시스템 변수 항목에서 `Path`를 더블클릭합니다.

![Path 수정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0038.jpeg?raw=true)

환경 변수 편집 창에 `C:\Program Files\Git\cmd` 경로를 추가합니다.

![경로 추가](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0039.jpeg?raw=true)

- - -

깃은 명령어 하나로만 동작하는 방법과 옵션을 같이 사용하여 동작하는 명령어로 나뉩니다. 

기본적으로 깃은 독립된 명령어들로 구성되어 있습니다. 

하지만 독립적인 명령어들 외에 하위 명령어들을 같이 이용하면 동작 기능을 세분화할 수 있습니다. 

다음과 같이 git 다음에 명령어 또는 옵션을 지정하면 됩니다.

```sh
$ git 명령어 또는 옵션
```

하위 명령어 외에 추가 옵션도 같이 지정할 수 있습니다. 

또 일부 옵션은 생략하기도 합니다. 

옵션은 짧은 옵션(`-`)과 긴 옵션(`--`)으로 구분합니다. 

다음과 같이 `help` 옵션을 입력하여 전체 명령어를 확인해 보세요.

```sh
$ git help –all
```

이제 깃 배시를 실행하여 간단한 실습을 따라해 봅시다. 

다음과 같이 `git –version` 명령어를 입력하고 실행해 보세요.

![version](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0040.jpeg?raw=true)

설치된 깃의 버전 정보를 확인할 수 있습니다. 

`git –version` 명령어를 사용하면 버전 확인 외에도 깃이 정상적으로 동작하는지 쉽게 확인할 수 있습니다.

깃 명령어는 명령어를 여러 개 묶어서 사용할 수도 있습니다. 

명령어를 묶어서 입력할 때는 세미콜론(;)으로 구분합니다. 

예를 들어 다음과 같이 태그 명령어와 브랜치 명령어를 같이 묶어서 실행할 수 있습니다. 

각 명령어는 뒷 장에서 설명하니 세미콜론만 보세요.

```sh
$ git tag; git branch # 세미콜론으로 구분
0.0.1
0.0.2
  footer
* master
```

#### 소스트리로 실행

소스트리를 같이 설치했다면 바탕화면에서 소스트리 아이콘을 확인할 수 있습니다.

아이콘을 클릭하면 소스트리를 실행합니다. 

뒤편부터 본격적으로 실습하므로 여기서는 간단히 몇 가지 항목만 확인할 것입니다. 

실행하면 다음과 같이 위쪽에 여러 버튼이 있습니다. 

여기서 Create 버튼을 클릭하면 새로운 깃 저장소 폴더를 만들 수 있고, Add 버튼을 클릭하면 로컬 PC에 만들어진 깃 저장소 폴더를 찾아 소스트리에 추가할 수 있습니다.

![SourceTree](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0041.jpeg?raw=true)

그리고 다음과 같이 로컬 PC의 깃 저장소 폴더와 소스트리의 저장소를 연결하여 사용하면 됩니다.

![깃과 소스트리가 연결된 화면](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0042.jpeg?raw=true)

소스트리를 저장소에 연결하면 오른쪽 위에 터미널 버튼이 생깁니다. 

책에서는 소스트리 설치 후 아무 작업도 하지 않았기 때문에 터미널 버튼이 보이지 않습니다. 

소스트리와 연결하고 나면 터미널 버튼을 확인할 수 있습니다.

이 버튼을 클릭하면 소스트리에서 바로 깃 배시 터미널을 실행할 수 있습니다. 

깃 배시가 실행될 때 현재 작업하는 저장소를 기준으로 터미널을 오픈합니다. 

명령어를 입력하여 경로를 이동할 필요가 없어 편리합니다.

![소스트리의 터미널](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0043.jpeg?raw=true)

이 책에서는 초보자도 쉽게 따라 할 수 있도록 그래픽 GUI인 소스트리도 함께 이용하여 설명합니다. 

하지만 깃 사용법에 좀 더 익숙해지면 다른 툴이나 터미널에서도 손쉽게 작업할 수 있을 것입니다. 

또 터미널은 다른 GUI들이 지원하지 않는 더 많은 기능도 지원합니다.

### 환경 설정

지금까지는 다양한 환경에서 깃을 설치하는 방법을 알아보았습니다. 

깃을 설치했다면 여러 가지 환경 설정도 해야 합니다. 

사용자 이름과 이메일 주소는 필수 항목이고, 그 외 나머지 항목은 옵션이므로 추가 항목은 가볍게 살펴봅니다.

#### config 명령어

깃은 환경 설정을 위해 별도로 config 명령어를 제공합니다. 

config 명령어는 환경 설정 파일을 직접 수정하지 않고도 환경 설정을 쉽게 할 수 있게 도와줍니다.

> git config

```sh
$ git config 설정값
```

config 명령어를 처음 실행하면 새로운 config 파일을 생성합니다. 

이전에 설정한 환경 파일이 있다면 기존 파일을 수정합니다.

다음 명령어처럼 기존에 설정된 환경 파일을 삭제할 수도 있습니다. 

–unset 옵션을 사용합니다.

```sh
$ git config –unset 이메일주소
```

- - -

* Note

config 명령어 역시 옵션을 사용할 수 있으며, -help 명령어로 확인 가능합니다.

```sh
$ git config -help
```

- - -

#### 로컬 사용자

깃은 여러 사람과 함께 개발할 수 있는 협업 도구입니다. 

프로젝트 하나를 다수의 개발자와 함께 작업할 때를 대비하여 각 개발자를 구분해야 합니다. 

따라서 깃은 각 개발자의 작업을 구분하려고 사용자를 등록하는 과정을 거칩니다. 

로컬 저장소에서 사용자 등록은 별도의 웹 사이트에서 회원 가입을 하는 것이 아니라, 소스 코드의 변경 내역을 기록할 때 구분할 수 있는 사용자 설정 값만 등록하면 됩니다. 

사용자 등록은 최초로 깃을 사용하거나 커밋할 때 한 번만 합니다.

사용자 등록은 크게 두 가지로 구분합니다. 

선택한 로컬(local) 저장소에만 적용되는 로컬 사용자 설정 값과 모든 로컬 저장소에 공통으로 적용되는 글로벌 사용자 설정 값입니다. 

깃에서는 사용자를 구분하려고 `사용자 이름`과 `이메일 주소`를 사용하며, config 명령어로 환경 설정 파일에 등록합니다.

로컬 저장소에서는 다음 형태로 사용자를 등록합니다. 

이때 사용자 이름과 이메일 주소는 한글로 입력하면 오류가 발생하므로 영문으로 작성해야 합니다. 

이메일 주소는 주로 사용하는 이메일 주소를 입력합니다.

```sh
$ cd 저장소 폴더 깃 저장소 폴더
$ git config user.name "사용자이름"
$ git config user.email "이메일주소"
```

깃에서 사용자를 구분하는 데 쓰는 `사용자 이름`과 `이메일 주소` 중 이메일 주소는 깃이 개발자를 구별하는 고유의 키 값으로 사용합니다. 

자신의 저장소를 외부로 공개하면 등록한 이메일 주소도 외부에 공개되므로, 공개해도 무관한 이메일 주소를 사용하길 권장합니다.

#### 글로벌 사용자(추천)

로컬 사용자 등록은 로컬 저장소를 생성할 때마다 설정해야 합니다. 

또 저장소마다 다르게 설정할 수 있습니다. 

하지만 저장소를 생성할 때마다 사용자 등록을 하는 것은 불편합니다.

혼자서 사용하는 컴퓨터라면 글로벌(공통된) 사용자 등록을 하는 것이 편리합니다. 

글로벌 사용자 등록을 할 때는 다음과 같이 `--global` 옵션을 함께 사용합니다. 

설정된 모든 값은 글로벌(global)(전역) 영역에 설정됩니다. 

책에서는 글로벌 사용자 등록을 할 것입니다.

```sh
$ git config –global user.name "사용자이름"
$ git config –global user.email "이메일주소"
```

그럼 다음과 같이 직접 설정해 봅시다. 

필자는 사용자 이름은 `kim0lil`로 설정하고, 이메일 주소는 `kim0lil@naver.com`으로 설정했습니다. 

여러분도 원하는 값으로 직접 설정해 보세요. 

이 값들은 나중에 소스트리와 연동할 때도 필요하므로 잘 기록해 두세요.

```sh
$ git config –global user.name "kim0lil"
$ git config –global user.email "kim0lil@naver.com"
```

- - -

* Note

자동으로 글로벌 사용자 등록을 적용하려면 생성된 저장소에서 별도로 로컬 사용자 등록을 하지 않아야 합니다.

- - -

#### 환경 설정 파일 확인 및 직접 수정

앞에서 config 명령어를 사용하여 간단히 사용자 등록을 했습니다. 

`config` 명령어로 만든 환경 설정 파일은 깃 저장소 안에 .git/config 파일 형태로 저장되어 있습니다. 

이 환경 설정 파일을 찾아 config 명령어로 등록한 내용이 제대로 적용되었는지 확인해 봅시다.

먼저 환경 설정 파일이 어디에 있는지 찾아야겠죠? 

일반적으로 다음 과정을 거칠 것입니다. 

먼저 로컬 저장소를 생성하고, 해당 저장소로 이동하여 (로컬) 사용자 등록을 한 후 설정 파일을 찾습니다.

```sh
$ mkdir gitstudy # 폴더 만들기 
$ cd gitstudy # 만든 폴더로 이동
$ git init  # 깃 초기화
$ git config user.name "kim0lil" # 로컬 사용자 이름 입력
$ git config user.email "kim0lil@naver.com" # 로컬 이메일 주소 입력
$ ls .git # 깃 목록 보기

branches  config  description  HEAD  hooks  index  info  logs  objects  packed-refs  refs
```

.git/config 파일은 로컬 저장소에서 직접 로컬 사용자 등록을 할 때만 찾을 수 있습니다. 

글로벌 사용자 등록을 했다면 저장소에 `.git/config` 파일은 존재하지 않습니다. 

그 대신 개인 계정 루트에 파일을 생성하므로 다음 명령어를 실행합니다.

```sh
ls ~/.gitconfig # .gitconfig 폴더의 경로 보기
```

컴퓨터에 글로벌 환경 설정 파일과 로컬 환경 설정 파일이 모두 있을 때도 있습니다.

이때는 로컬 환경 설정 파일의 내용을 우선 적용합니다.

환경 설정 파일을 찾았다면 간단히 `cat` 명령어로 내용을 확인할 수 있습니다.

```sh
$ cat .git/config
[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true

[user]
        name = hojinlee
        ...
```

환경 설정 파일을 직접 열어 수정하고 싶다면 다음 명령어를 실행합니다. VS Code 편집기를 사용합니다.

- - -

* Note. 깃 상태를 컬러로 보기

깃 전용 터미널(배시)에서 다음 옵션을 설정하면 깃 상태를 컬러로 볼 수 있습니다.

다음 명령어를 사용하면 전역으로 설정됩니다.

```sh
$ git config –global color.ui auto
```

- - -

#### 소스트리의 환경 설정

소스트리에서도 환경 설정을 할 수 있습니다. 

GUI 환경이라 좀 더 편리합니다. 

소스트리를 실행한 후 `도구 > 옵션` 메뉴를 선택하면 다음과 같이 환경 설정 화면이 나옵니다. 

여기서 이름과 이메일 주소 항목은 필수입니다. 

일반적으로 소스트리를 설치할 때 입력했던 사용자 이름과 이메일 주소가 자동으로 입력되어 있습니다. 

필자는 이름은 `kim0lil`로, 이메일 주소는 `kim0lil@naver.com`으로 입력했기 때문에 해당 값이 자동으로 입력되어 있습니다.

![소스트리 환경 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0044.jpeg?raw=true)

#### 별칭

좀 더 고급 환경 설정으로 별칭을 사용할 수 있습니다. 

별칭은 복잡한 깃 명령어를 단순하게 닉네임 형태로 등록해 두는 기능입니다. 

예를 들어 다음과 같이 `log –graph –pretty=oneline` 명령어를 `show-graph`라는 별칭으로 등록해 두면 이후로는 이 별칭을 사용할 수 있습니다.

```sh
$ git config -global alias.show-graph 'log –graph –pretty=oneline'
```

### 비주얼 스튜디오 코드

깃에서 실습하다 보면 코드를 작성해야 할 때가 있습니다. 

코드를 작성하려면 코드 편집기가 필요합니다. 

코드 편집용 툴로 비주얼 스튜디오 코드(VS Code, Visual Studio Code)를 사용합니다. 

VS Code는 무료로 내려받아 설치할 수 있습니다. 

또는 자신에게 익숙한 다른 편집기를 사용해도 됩니다.

VS Code는 다음과 같이 터미널에서 명령어로 쉽게 실행할 수 있습니다.

```sh
$ code 파일이름
```

### 정리

지금까지 깃의 기본적인 설치 방법과 환경 설정을 알아보았습니다. 

모든 학습이 그렇듯이 처음에 프로그램을 설치하고 환경 설정을 하는 데 많은 시간이 소요됩니다. 

책 내용을 천천히 따라가면서 자신만의 개발 환경을 설정하세요. 

다음 장부터는 깃의 개념과 사용법을 하나씩 알아보겠습니다.

## 깃 개념 잡기

이 장에서는 깃의 저장소 개념을 알아보고, 직접 생성해 봅니다. 

깃을 효과적으로 잘 사용하려면 저장소의 동작 원리를 이해하는 것이 중요합니다.

![저장소 생성과 사용자 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0045.png?raw=true)

![소스트리에서 저장소 생성과 사용자 설정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0046.png?raw=true)

### 깃 저장소 생성

깃은 작성된 소스 코드 파일의 모든 변경 사항을 관리합니다. 

그렇다면 깃은 파일의 변경 내역을 어떻게 저장하고 관리할 수 있을까요? 

깃은 이러한 변경 사항을 전용 저장소(repository)(리포지터리)에 저장합니다. 

이 저장소는 일반적으로 사용하는 폴더와 유사하지만, 조금 차이가 있습니다. 

깃의 동작 방식을 이해하려면 저장소 동작 원리를 확실히 알아야 합니다. 

이제부터 하나씩 알아봅시다.

#### 폴더와 깃 저장소

컴퓨터의 파일과 폴더는 운영 체제의 파일 시스템에 의존하여 동작합니다. 

파일 시스템은 하드디스크 같은 장치에 데이터를 저장하고 관리합니다. 

그중 폴더는 파일 여러 개를 하나로 관리할 수 있는 논리적 개념입니다. 

마치 파일을 그룹으로 묶어 놓은 것과 같습니다.

그렇다면 깃은 파일의 변경 내역을 어떻게 저장하고 관리할 수 있을까요? 

깃 저장소는 외형적으로 폴더와 유사합니다. 

사용자 입장에서는 일반 폴더와 깃 저장소를 구별 없이 모두 동일하게 사용할 수 있습니다. 

하지만 깃 저장소는 내부적으로 구조가 다릅니다. 

깃 저장소에는 별도의 숨겨진 영역(숨겨진 폴더)이 있는데, 여기에 버전 관리 시스템(VCS, Version Control System)에 필요한 파일 변경 이력을 기록합니다. 

저장소는 프로젝트의 모든 리비전(revision)(개정)과 히스토리를 가진 데이터베이스와 같습니다.

즉, 일반적인 폴더와 깃 저장소 차이점은 숨겨진 영역이 있는지 여부입니다.

#### 초기화

그럼 깃 저장소의 숨겨진 영역을 살펴보면서 저장소를 좀 더 알아봅시다. 

저장소를 생성하려면 먼저 초기화 작업이 필요합니다. 

깃에서 초기화란 이미 존재하는 폴더에 초기화 명령어로 VCS 관리를 위한 숨겨진 영역을 생성하는 작업을 의미합니다.

깃 초기화를 해 봅시다. 

먼저 터미널(깃 배시)을 실행합니다.

- - -

* Note

터미널은 텍스트로 명령어를 입력할 수 있는 대화창입니다. 

깃 배시 터미널 프로그램 외에도 윈도에 기본 내장된 CMD, powerShell 등을 사용해도 됩니다. 

책에서는 깃 배시를 기준으로 합니다. 

윈도 메뉴 말고 바탕화면의 깃 배시 아이콘으로 실행해도 됩니다.

- - -

실습에 필요한 새 폴더를 하나 만들겠습니다. 

또는 기존에 있던 폴더에서 시작해도 괜찮습니다. 

먼저 실습 폴더를 만들고 해당 폴더로 이동합니다. 

책에서는 study 폴더를 만들고 해당 폴더로 이동했습니다.

```sh
$ mkdir code # 새 폴더 만들기
$ cd code # 만든 폴더로 이동
```

- - -

* Note. 지정된 폴더에서 깃 배시 열기

명령 프롬프트에서 원하는 경로로 이동하기 불편하다면, 윈도 탐색기를 사용하여 원하는 폴더로 이동한 후 해당 폴더에서 터미널을 열 수 있습니다. 원하는 폴더에서 마우스 오른쪽 버튼을 누른 후 Git Bash Here 메뉴를 선택합니다.

![지정된 폴더에서 깃 배시 열기](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0047.jpeg?raw=true)

- - -

이제 터미널에서 다음 초기화 명령어를 입력합니다. 

깃 명령어는 보통 git 키워드와 명령어를 함께 입력합니다. 

옵션을 추가할 수도 있습니다.

```sh
$ git init 경로명
```

앞에서 설명했듯이 git init 명령어는 기존 폴더에 숨겨진 영역(숨겨진 폴더)을 추가합니다. 

숨겨진 영역을 추가함으로써 깃 저장소로 변경되는 것입니다.

초기화 명령어를 입력할 때 경로명을 입력하지 않으면, 현재 폴더에서 초기화됩니다. 

우리는 원하는 폴더로 이동한 상태이므로 경로명을 입력하지 않고 실행할 것입니다. 

정상적으로 초기화되었다면 `Initialized empty~` 같은 메시지를 출력합니다.

깃 초기화는 완전히 비어 있는 폴더나 기존에 사용하던 폴더에서 모두 가능합니다.

![깃 초기화](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0048.png?raw=true)

앞에서 언급했듯이 깃 저장소는 영어로 `리포지터리`라고 하니, 두 용어를 혼동하지 말고 동일한 것으로 이해하면 됩니다.

초기화된 저장소에서 `숨긴 항목`을 볼 수 있게 허용하면, 숨겨진 영역을 확인할 수 있습니다.

git init 명령어는 기본적으로 로컬 저장소를 생성하며, 다양한 옵션을 추가로 제공합니다. 

추가 옵션을 사용하여 원격 저장소도 초기화할 수 있습니다. 

원격 저장소는 뒤편에서 설명합니다.

#### 파일의 untracked 상태와 tracked 상태

깃의 추적(tracked) 개념을 알아봅시다. 

깃이 다른 VCS보다 뛰어난 것은 지정된 파일들의 모든 것을 추적하는 관리 시스템이기 때문입니다. 

깃은 워킹 디렉터리에 있는 파일들을 `추적됨`과 `추적되지 않음` 상태로 구분합니다.

##### untracked 상태

실제 작업 중인 파일은 워킹 디렉터리 안에 있습니다. 

워킹 디렉터리는 현재 작업 중인 소스 코드를 담고 있으며, 운영 체제도 워킹 디렉터리 안에 있는 파일들만 접근하고 수정할 수 있습니다.

워킹 디렉터리는 사용자 작업 공간이라고 생각하면 됩니다. 

이 공간에 파일을 추가하거나 수정했다고 해서 깃이 자동으로 관리해 주지는 않습니다. 

워킹 디렉터리에 새로 생성된 파일은 모두 추적되지 않음(untracked) 상태입니다. 

이 파일을 관리하려면 깃에 추적하라고 통지해 주어야 합니다. 

통지하지 않은 파일은 깃에서 따로 추적하지 않습니다.

#### tracked 상태

워킹 디렉터리에 새 파일을 추가하면 `추적되지 않음(untracked)` 상태입니다. 

워킹 디렉터리 안에 추적되지 않는 상태의 파일들은 별도로 명령어를 실행하여 추적(tracked) 상태로 변경해 주어야 합니다. 

이때는 git add 명령어를 사용합니다.

![git add 명령어를 실행하여 추적 상태로 변경](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0049.png?raw=true)

깃이라고 모든 파일을 자동으로 완벽하게 관리할 수는 없습니다. 

수많은 파일을 모두 자동으로 처리해야 한다면 시스템에 엄청난 부하가 발생됩니다.

깃은 요청받은 파일들만 추적 관리합니다. 

사실 깃 입장에서는 어떤 파일이 정말로 추적 관리가 필요한지 알 수 없습니다. 

따라서 추적하는 파일들은 tracked 상태로 표시합니다. 

깃이 tracked와 untracked 개념을 사용하는 것은 시스템 부하를 줄이고, 좀 더 효율적으로 파일 이력을 관리하기 위해서입니다.

실제로 개발 작업을 할 때 워킹 디렉터리의 파일들은 아주 빈번하게 수정됩니다.

개발자에게 관리할 파일 목록들을 제출해 달라고 요청하는 것이 더 현명합니다. 

따라서 요청받은 파일들만 이력을 관리한다면 매번 파일 목록을 추적하려고 많은 리소스를 낭비할 필요가 없습니다. 

이렇게 관리할 파일 목록에 등록된 상태를 추적 상태라고 합니다.

### 스테이지

깃은 여러 단계의 논리적인 저장 공간을 가지고 있습니다. 

스테이지(stage)는 `임시로 저장하는 공간`을 의미합니다. 

스테이지 영역은 워킹 디렉터리에서 제출된 tracked 파일들을 관리합니다. 

이 영역은 나중에 배울 커밋 작업과 연관이 매우 많습니다.

#### 임시 영역

스테이지는 워킹 디렉터리와 `실제로 저장하여 기록하는 공간` 사이에 있는 임시 영역입니다. 

깃은 워킹 디렉터리에서 작업이 끝난 파일을 스테이지로 잠시 복사합니다. 

스테이지가 임시 영역이라고 해서 파일의 콘텐츠 내용을 직접 가지고 있지는 않습니다. 

단지 커밋하려는 파일의 추적 상태 정보들만 기록합니다.

![스테이지는 커밋하려는 파일의 추적 정보만 기록](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0050.png?raw=true)

이처럼 임시 영역인 스테이지를 별도로 운영하는 것은 커밋을 빠르게 처리하기 위해서입니다. 

`실제로 저장하여 기록하는 공간`인 저장소는 스테이지 영역에서 가리키는 파일 내용을 기반으로 변경된 차이점만 기록합니다.

파일들의 스테이지 상태는 status 명령어로 확인 가능합니다. 

또는 깃의 `git ls-files` 같은 명령어로도 확인 가능합니다.

```sh
$ git status
$ git ls-files --stage
```

스테이지 영역에 등록된 파일들은 또 다시 `stage` 상태와 `unstage` 상태로 구분됩니다. 

버전 관리에서 제외하고 싶은 파일이 있다면 .gitignore 파일에 등록합니다. 

`.gitignore` 파일은 뒤편에서 설명합니다.

#### 파일의 stage 상태와 unstage 상태

워킹 디렉터리에 있는 `tracked` 상태의 파일들은 스테이지 영역과 긴밀한 상관 관계를 맺습니다. 

스테이지 영역으로 등록된 모든 파일은 `untracked` 상태에서 `tracked` 상태로 변경됩니다. 

스테이지는 워킹 디렉터리 안에 있는 파일들의 추적 상태를 관리하는 역할을 수행합니다.

스테이지 영역은 파일을 `stage` 상태와 `unstage` 상태로 구분합니다. 

깃이 변화 이력을 기록하려면 파일들의 최종 상태가 `stage` 상태여야 합니다. 

`unstage` 상태라면 파일에 변화가 있다는 것을 의미합니다. 

즉, 스테이지 영역에 있는 파일과 워킹 디렉터리 안에 있는 파일 내용에 차이가 있을 때는 `unstage` 상태가 됩니다.

또 넓게 보면 아직 스테이지 영역으로 등록하지 않은 워킹 디렉터리 안의 파일도 `unstage` 상태라고 생각할 수 있습니다. 

이때는 `unstage` 상태이자 동시에 `untracked` 상태입니다.

`unstage` 상태라고 해서 실제 파일이 없어지는 것은 아닙니다. 

단지 파일이 수정되어 임시적으로 스테이지 목록에서 제외된 것입니다. 

`git add` 명령어를 사용하면 스테이지에 다시 추가할 수 있습니다.

#### 파일의 modified 상태와 unmodified 상태

코드를 변경한다는 것은 워킹 디렉터리에서 파일을 수정하는 것을 의미합니다. 

파일이 수정되면 워킹 디렉터리와 스테이지 간 내용이 일치하지 않습니다. 

따라서 스테이지는 수정한 파일과 원본 파일을 구분하려고 수정함(modified) 상태와 수정하지 않음(unmodified) 상태로 표현합니다. 

파일 수정 작업은 스테이지 영역과 긴밀한 상관관계를 맺습니다.

* modified 상태

스테이지에 등록된 파일은 깃이 추적 관리합니다. 

깃이 실제로 기록한 파일이며, 사실상 버전을 의미합니다. 

파일 수정은 개발 과정에서 뗄 수 없는 작업입니다. 

개발 작업에서 수많은 코드가 변경되고, 깃을 사용하면 이 변경 내역은 영구적으로 기록됩니다.

앞에서 설명했듯이 깃은 tracked 상태인 파일만 수정 여부를 관리할 수 있습니다. 

`tracked` 상태인 파일이 수정되면 스테이지는 파일 상태를 `modified` 상태로 변경합니다.

![파일 수정 여부 확인](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0051.png?raw=true)

그러면 수정된 파일은 스테이지에서 잠시 제외됩니다. 

깃은 수정 여부만 체크해 주기 때문에 `modified` 상태로 변경된 파일은 스테이지로 재등록해야 합니다.

수정된 파일을 스테이지 영역으로 다시 적용하려면 `git add` 명령어로 재등록합니다.

* unmodified 상태

unmodified 상태는 tracked 상태이면서 스테이지에서 한 번도 수정하지 않은 원본 상태를 의미합니다. 

이처럼 수정하지 않은 파일들은 재등록하지 않아도 됩니다. 

스테이지에 등록한 후 어떤 수정도 하지 않았다면 unmodified 상태입니다. 

깃은 파일의 수정 여부를 체크하고, 스테이지 영역의 갱신 작업 여부를 작업자에게 알려 줍니다.

이전에 배운 개념을 그림 하나로 정리하면 다음과 같습니다. 

워킹 디렉터리에서 등록 명령(git add 명령어)을 실행하면 스테이지에 등록됩니다. 

이때 자동으로 tracked 상태가 됩니다. 

파일을 수정하지 않으면 계속 stage 상태에 머무릅니다. 

파일이 수정되면 modified 상태가 되고, 스테이지에서 떨어져 나와 unstage 상태가 됩니다. 

unstage 상태의 파일은 워킹 디렉터리에 잠시 담아 둡니다. 

이때 다시 등록 명령을 실행하면 stage 상태로 변경됩니다.

![워킹 디렉토리와 스테이지 상태](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0052.png?raw=true)

### 파일의 상태 확인

상태 개념은 깃의 분리된 저장 영역인 워킹 디렉터리와 스테이지, 추적 여부를 의미합니다. 

깃이 이렇게 다양한 저장 영역을 구분해서 가지고 있는 것은 파일들의 상태를 효율적으로 모니터링하기 위해서입니다. 

이번에는 파일들의 상태를 모니터링할 수 있는 `status` 명령어를 알아봅니다.

#### status 명령어로 깃 상태 확인

파일을 생성하고 수정한다는 것은 변화를 의미합니다. 

또 이러한 변화들은 순서가 있습니다. 

깃은 각 저장 영역에서 일어나는 다양한 변화를 감시합니다. 

그리고 이러한 변화를 감지하고 상태 메시지를 출력합니다.

status 명령어를 사용하면 깃의 상태 메시지를 확인할 수 있습니다. 

특히 status 명령어는 많이 사용하는 깃 명령어 중 하나입니다.

터미널(깃 배시)에서 status 명령어를 입력합니다

```sh
$ git status # 상태 확인
On branch master
No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

우리는 처음 깃 저장소를 생성하고, 실습 이후에 아무 작업도 하지 않았습니다. 

status 명령어를 실행하면 이처럼 변경된 내용과 커밋이 없다고 메시지를 출력할 것입니다. 

나중에 커밋 명령을 수행하면 status 명령어로 파일들의 변경된 상태를 확인할 수 있습니다.

### 파일 관리 목록에서 제외: .gitignore

깃은 tracked 상태인 모든 것을 추적 관리합니다. 

파일뿐만 아니라 서브 폴더와 그 안의 파일들도 포함합니다. 

즉, 디렉터리 전체가 모두 관리 대상입니다. 

하지만 프로젝트를 하다 보면 모든 파일을 추적하지 않아야 하는 경우도 있습니다.

실제 작업하다 보면, 워킹 디렉터리에 불필요한 파일이 생성되거나 보안에 민감한 파일들이 있을 수 있습니다. 

로컬 저장소를 혼자만 사용한다면 이러한 파일들은 신경 쓰지 않아도 됩니다. 

하지만 자신의 저장소를 다른 사람들과 공유한다면 이 파일들은 분리해서 관리해야 합니다.

깃으로 관리하고 싶지 않은 파일과 폴더는 별도의 `.gitignore` 설정 파일 안에 나열해서 적어 줍니다.

#### .gitignore 파일

`.gitignore`는 git과 ignore(무시하다)의 합성어입니다. 

워킹 디렉터리 안에 `.gitignore` 파일을 생성합니다. 

이 파일은 앞에 점(`.`)이 있어 숨겨진 파일로 관리됩니다.

.gitignore 파일은 깃에서 관리하지 않는 파일들의 목록을 가지고 있습니다. 

깃은 이 파일에 작성된 목록들을 추적하지 않습니다. 

또 로컬 저장소를 서버로 전송하거나 다른 사람과 공유할 때도 이를 분리하여 처리합니다.

`.gitignore` 파일은 텍스트 에디터를 이용하여 간단하게 작성할 수 있습니다. 

특별한 도구 없이 파일 이름만 `.gitignore`로 만들면 됩니다. 

깃에서 제외할 파일 목록을 직접 적어 주거나 규칙을 사용하여 나열할 수 있습니다. 

`.gitignore` 파일을 작성할 때는 저장소 폴더의 최상위 디렉터리에 두어야 합니다.

#### .gitignore 파일 표기법

파일에서 `#`으로 시작하는 줄은 주석으로 처리합니다. 

`#` 없이 완전한 파일 이름을 적어 주면 그 파일은 깃의 관리 대상에서 제외됩니다. 

이때 경로가 있다면 경로명도 같이 입력해야 합니다.

```sh
# DB 접속 파일을 제외함
dbinfo.php
```

애스터리스크(`*`) 기호를 사용하여 패턴을 정의할 수 있습니다. 

기호는 모든 문자열을 대체할 수 있습니다. 

이러한 문자를 셸 글로빙(`globbing`)이라고 합니다. 

글로빙 문자를 사용하여 패턴을 확장합니다.

```sh
# 오브젝트 파일은 제외함
*.obj
```

ignore 패턴을 작성할 때 반드시 추적 관리를 제외하는 파일만 작성하는 것은 아닙니다. 

제외하지 않는 파일과 필요한 파일은 파일 이름 앞에 느낌표(!)를 사용합니다. 

느낌표는 부정을 의미하는 not과 같습니다.

```sh
# 환경 설정 파일은 제외하면 안 됨
!config.php
```

운영 체제별로 디렉터리를 표현하는 방법이 다릅니다. 

깃에서 디렉터리를 표현할 때는 리눅스와 같이 슬래시(`/`) 기호를 사용합니다.

```sh
# 현재 디렉터리 안에 있는 파일 무시
/readme.txt

# /pub/ 디렉터리 안의 모든 것을 무시
/pub/

# doc 디렉터리 아래의 모든 .txt 파일 무시
doc/**/*.txt
```

깃은 `glob` 패턴을 지원하기 때문에 정규 표현식을 응용하여 작성 규칙을 넣을 수도 있습니다.

### 깃 저장소 복제

초기화 명령(git init 명령어)은 새 저장소를 생성하는 방법 중 하나입니다.

처음 프로젝트를 시작할 때는 직접 로컬 컴퓨터에 명령어를 실행하여 저장소를 생성합니다.

외부에 있는 기존 프로젝트(깃허브, 비트버킷)를 기반으로 저장소를 생성하고 싶다면 어떻게 해야 할까요? 외부 저장소를 복제해서 생성할 수 있습니다. 

이처럼 외부 저장소를 이용하여 로컬 저장소를 생성하는 것을 `깃 저장소 복제`라고 합니다.

![외부의 깃 저장소 복제](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0053.png?raw=true)

#### 공개 저장소

깃은 다수의 사람과 코드를 공유하고 협업하여 개발하는 도구입니다. 

이미 깃을 기반으로 하는 공개 저장소가 여럿 있습니다. 

대표적으로 깃허브, 비트버킷 같은 깃 호스팅 사이트가 있습니다(외부 저장소, 서버 관련 내용은 뒤편에서 설명합니다).

깃 호스팅 서비스는 공개된 저장소와 비공개된 저장소를 모두 지원합니다. 

공개된 저장소는 누구나 복제하여 코드를 내려받을 수 있습니다. 

요즘은 오픈 소스가 활성화되어 저장소를 공개하고 있습니다. 

이미 수많은 오픈 소스를 깃으로 관리하고, 공개 저장소를 이용하여 배포합니다.

#### 다운로드 vs 복제

일반적으로 공개된 소스 코드를 얻으려면 웹 사이트에서 압축 파일을 내려받습니다. 

소스 코드를 내려받는다는 것은 해당 코드의 최종 복사본을 내 컴퓨터로 가져오는 것입니다. 

하지만 이러한 내려받기는 깃의 이력을 포함한 저장 영역까지 내려받는 것은 아닙니다.

![공개된 소스 코드의 최종 복사본 내려받기](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0054.jpeg?raw=true)

이와 달리 깃을 이용하여 저장소를 복제하면, 최종 코드뿐만 아니라 중간에 커밋 같은 변화의 모든 이력도 같이 내려받을 수 있습니다.

또 일부 코드를 변경하여 기여하는 것도 가능할 것입니다.

#### 복제 명령어

깃의 저장소를 복제하는 명령어는 clone입니다. 

복제하려면 공개된 저장소의 URL이 필요합니다. 

복제할 때 폴더 이름을 지정하지 않으면 공개 저장소에서 사용된 폴더와 동일한 이름으로 새 폴더를 만듭니다. 

다른 이름으로 복제하길 원한다면 새 폴더 이름을 추가 인자로 적어 줍니다.

> git clone

```sh
$ git clone 원격저장소URL 새폴더이름
```

git clone 명령어를 사용하면 깃은 자동으로 깃 서버에 접속합니다. 

그리고 저장소의 모든 소스 코드를 자동으로 내려받습니다.

깃은 저장소 안에 있는 파일들과 `.git` 리포지터리를 기반으로 이력을 관리합니다. 

따라서 복제한 후에는 복제된 폴더 이름을 그대로 사용하지 않아도 됩니다. 

필요에 따라 깃의 폴더 이름을 변경해도 괜찮습니다.

### 정리

이 장에서는 깃 저장소와 저장소 개념을 학습했습니다. 

앞으로 깃을 학습하려면 이 장에서 배운 저장소 개념을 잘 알고 있어야 합니다. 

또 각 용어들을 구분하고 이해하는 것도 필요합니다(특히 워킹 디렉터리와 스테이지 영역). 

각 장의 기능을 학습하다 용어 이해가 부족하다고 느낄 때 이 장을 다시 읽어 보는 것도 좋습니다.

## 커밋

깃을 사용하여 개발 중인 소스 코드의 이력을 만들 수 있습니다. 그중 가장 기본인 커밋을 알아보겠습니다. 커밋은 깃에서 ‘코드의 변화를 기록하는 것’을 의미합니다.

![파일 생성 및 추적 등록](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0055.png?raw=true)

![커밋으로 이력 생성](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0056.png?raw=true)

![파일 수정 및 이력 관리](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0057.png?raw=true)

### 코드의 변화

깃은 개발 중인 코드의 이력을 만들 수 있습니다. 

깃이 코드 변화를 기록하는 것을 커밋(`commit`)이라고 합니다. 

먼저 커밋의 뜻부터 알아봅시다. 

영어로 `commit`은 여러 의미가 있습니다. 

그중 깃의 동작과 가장 유사한 의미는 `~를 적어 두다`입니다. 

즉, 커밋은 의미 있는 변경 작업들을 저장소에 기록하는 동작입니다.

개발 과정에서 소스 코드는 수없이 수정됩니다. 

일반적으로는 새로운 기능을 추가하는 코드를 삽입합니다.

또 버그를 수정하려고 많은 코드를 이동하거나 대체합니다.

이러한 코드 수정은 개발 목적을 달성하는 작업들입니다.

예를 들어 다음과 같이 텍스트 코드를 수정한다고 합시다.

![파일 변경 처리](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0058.png?raw=true)

작업자는 개발 과정에서는 수정 내용을 기억하지만, 변경된 내용이 많거나 시간이 흐르면 이를 모두 기억하기 어렵습니다. 

개발하는 도중 실수나 여러 가지 이유로 변경 전 시점으로 되돌아가야 한다면 어떻게 해야 할까요?

수정된 모든 코드 작업을 하나씩 되돌리면서 과거 시점까지 수정해야 할 것입니다. 

하나라도 빠지거나 기억하지 못한다면 어떻게 할까요? 

난감할 것입니다. 

그래서 개발자는 만일의 경우에 대비하여 중간에 코드 변경 과정을 기록하길 원합니다. 

변경 시점을 저장해 두면 잘못된 동작을 발견했을 때 특정 시점으로 되돌아갈 수 있습니다.

이때 필요한 것이 깃의 버전 관리입니다. 

깃은 코드의 변경 이력과 시점을 커밋으로 기록합니다. 

사용자가 일일이 기억하지 않아도 됩니다. 

또 이전 시점으로 쉽게 되돌아갈 수 있으며, 실수도 없습니다.

#### 파일 관리 방법

먼저 깃이 없던 시절, 전통적인 파일의 이력 관리 방법을 알아봅시다. 

보통 우리는 의미 있는 변경을 할 때 파일을 복사합니다. 

그리고 복사한 새 파일에는 추가하거나 변경하고 싶은 내용을 적용합니다. 

하지만 이렇게 파일을 복사하는 형태는 파일의 변경 내역을 기록하는 것보다 더 많은 파일을 생성하고 관리해야 하는 부작용이 있습니다. 

모든 내용이 중복되기 때문에 용량도 많이 차지합니다.

![파일 복사로 파일 관리](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0059.png?raw=true)

반면 깃의 커밋은 새로 변경된 부분만 추출하여 저장합니다. 

그것도 파일 이름을 변경하지 않고도 동일한 파일 이름으로 하나로 관리가 가능합니다. 

즉, 시간에 따라 변화되는 내용만 관리하고, 코드가 변화된 시간 순서에 따라서 영구적으로 저장합니다. 

이를 커밋이라고 합니다.

![깃으로 파일 관리](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0060.png?raw=true)

개발자 입장에서는 복잡한 구조의 파일을 관리하지 않아도 되고, 여러 개의 파일보다는 파일 하나로 모든 이력을 처리하기 때문에 유용합니다. 

커밋은 부모 커밋(parent commit)을 기반으로 변화된 부분만 새로운 커밋으로 생성합니다. 

그리고 커밋은 파일의 시간적 변화도 함께 저장합니다.

### 새 파일 생성 및 감지

커밋을 직접 실습해 봅시다. 워킹 디렉터리에 새로운 파일을 하나 생성하여 커밋 과정을 따라가 보겠습니다.

#### 새 파일 생성

실습을 위해 간단한 HTML 파일을 하나 작성합니다. 

에디터를 이용하여 코드를 작성하면 됩니다. 필자는 VS Code를 이용하겠습니다.

```sh
$ mkdir code # 새 폴더 만들기
$ cd code # 만든 폴더로 이동
$ git init # 저장소를 깃으로 초기화
$ code index.htm # VS Code를 사용하여 파일 작성
```

아래는 html 태그입니다.

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset=“utf-8” />
        <meta name=“viewport” content=“width=device-width, initial-scale=1”>
        <title>Page Title</title>
    </head>
    <body>

    </body>
</html>
```

작성한 예제 파일은 기본이 되는 HTML의 뼈대 페이지입니다. 

파일 생성 과정을 그림으로 표현하면 다음과 같습니다.

![파일 생성 과정](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0061.png?raw=true)

이렇게 파일을 생성하면 워킹 디렉터리에 `index.htm` 이름으로 저장됩니다. 

모든 작업은 워킹 디렉터리 안에서 진행됩니다.

#### 깃에서 새 파일 생성 확인

워킹 디렉터리에 새 파일이 생성되었습니다. 

워킹 디렉터리에 새 파일이 추가되면 깃은 변화된 상태를 자동으로 감지합니다.

이때 깃 상태를 확인할 수 있는 명령어가 `status`입니다.

`status` 명령어를 입력하면 메시지가 출력되는 것을 볼 수 있습니다.

> git status

```sh
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        .ipynb_checkpoints/
        index.html
        track_file
        ...
```

깃의 상태 메시지에서 `Untracked files` 표시 부분을 확인합니다. 

깃 배시 터미널로 실행하면 추적되지 않은 파일은 빨간색으로 표시합니다. 

`Untracked files` 메시지는 워킹 디렉터리에 새로운 파일이 등록되었다고 알려 주는 것입니다.

이렇게 깃은 워킹 디렉터리에 새 파일이 추가되면 상태를 감지하고 향후 이력을 추적할지 여부를 결정합니다.

- - -

Note

모든 실습은 깃의 계정 및 환경 설정이 된 상태에서 진행합니다. 

혹시 앞 장들을 읽지 않고 바로 시작했다면 앞 장들로 이동하여 계정과 환경 설정을 하세요.

- - -

### 깃에 새 파일 등록

깃의 워킹 디렉터리에 새 파일이 생성되었습니다. 

워킹 디렉터리에 있는 파일은 깃이 자동으로 추적 관리하지 않습니다. 

커밋을 하려면 파일의 상태가 추적 가능해야 합니다.

워킹 디렉터리에 새로 추가된 untracked 상태의 파일을 추적 가능 상태로 변경하는 것을 등록이라고 합니다. 

또 파일을 등록하면 워킹 디렉터리의 파일이 스테이지 영역에 추가됩니다. 

스테이지 영역의 관리 목록에 추가된 파일만 깃에서 이력을 추적할 수 있습니다.

![새 파일 등록](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0062.png?raw=true)

워킹 디렉터리는 작업을 위한 일종의 샌드박스(서로 분리되어 있는 영역)와 같습니다.

#### 스테이지에 등록

깃에서 등록이란 정확히 무엇을 의미할까요? 

등록이란 워킹 디렉터리에 있는 파일을 스테이지(`stage`) 영역으로 복사(`copy`)하는 것을 의미합니다. 

여기서 `copy`는 실제 파일을 복사하는 것을 의미하지는 않습니다. 

깃 내부에서 논리적인 기록을 변경하는 과정일 뿐입니다. 

복사라고 표현한 것은 이해하기 쉽게 풀어 쓴 것입니다.

워킹 디렉터리에 추가된 모든 파일을 커밋할 때는 반드시 이 과정을 거쳐야 합니다. 

그래야 깃에서 버전 이력을 관리할 수 있습니다. 

스테이지에 등록되지 않은 `unstage` 상태의 파일들은 커밋할 수 없습니다. 

깃은 커밋하기 전에 파일들이 `stage` 상태인지 `unstage` 상태인지를 판단합니다. 

스테이지 영역으로 등록된 파일들은 `tracked` 상태로 자동 변경됩니다.

> git add

현재는 커밋 명령어를 실행하기 이전의 중간 단계입니다. 

깃의 `add` 명령어는 워킹 디렉터리의 파일을 스테이지 영역으로 등록합니다. 

깃은 안정적인 커밋을 할 수 있도록 `add` 명령어를 기준으로 이전과 이후 단계를 구별합니다.

터미널에서는 다음 형태의 명령어를 입력합니다.

```sh
$ git add 파일이름
```

그럼 index.htm 파일을 등록합시다.

```sh
$ git add index.htm # 스테이지에 등록

$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        track_file

```

index.htm 파일을 등록하는 과정은 다음과 같이 표현할 수 있습니다.

![스테이지 영역에 등록](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0063.png?raw=true)

add 명령어를 실행하면 지정한 파일은 스테이지 영역으로 등록됩니다. 

스테이지 영역에 파일이 등록되면 파일은 `tracked` 상태로 변경됩니다.

파일 이름 대신 점(`.`)을 이용하면 전체 파일과 폴더를 모두 등록할 수 있습니다. 

점(`.`)은 리눅스와 같은 운영 체제에서 현재 디렉터리를 의미하는 기호입니다.

```sh
$ git add .
```

워킹 디렉터리에 생성된 모든 파일을 스테이지 영역에 추가할 필요는 없습니다. 

필요한 파일만 스테이지 영역에 등록하여 이력을 추적하면 됩니다. 

스테이지 영역에 등록하지 않은 파일은 커밋 작업에 포함되지 않습니다. 

등록 명령으로 파일들의 이력을 커밋 기록에 포함할지 여부를 결정할 수 있습니다. 

정보 이력을 추적하고 싶은 파일만 스테이지 영역에 추가합니다. 

단 빈 폴더는 스테이지 영역에 등록할 수 없습니다. 

폴더 안에 파일이 하나 이상 있어야 등록이 가능합니다.

#### 파일의 추적 상태 확인

워킹 디렉터리에 있는 새로운 파일이 스테이지 영역에 등록되었습니다. 

콘솔창에서 `status` 명령어를 사용하여 등록 상태를 다시 한 번 확인해 보겠습니다.

```sh
$ git status # 상태 확인

On branch master
No commits yet
Changes to be committed:
  (use “git rm –cached <file>…” to unstage)
        new file:   index.htm # 스테이지에 등록, 새 파일 상태
```

이전 상태와 달리 `new file` 메시지가 출력됩니다. 

이는 스테이지 영역에 파일을 정상적으로 등록했다는 의미입니다.

앞으로 좀 더 학습해야 하지만, 스테이지 영역에 등록되었다고 커밋이 된 것은 아닙니다. 

아직 커밋 명령어를 학습하지 않았습니다. 등록은 커밋을 하기 전 선행 작업일 뿐입니다.

#### 파일 등록 취소

번에는 tracked 상태의 파일을 `untracked` 상태로 변경해 보겠습니다. 

스테이지에 등록하는 것과 반대 과정입니다. 

등록 취소는 워킹 디렉터리와 스테이지 영역을 서로 왔다 갔다 할 수 있는 방법입니다.

`unstage` 상태로 변경하려면 삭제(`rm`)나 리셋(`reset`) 명령어를 사용합니다.

![스테이지 영역에 등록 취소](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0064.png?raw=true)

rm 명령어로 삭제해 보겠습니다. 

스테이지 영역에서만 등록된 파일을 삭제하려고 –cached 옵션을 함께 사용합니다.

> git rm

```sh
$ git rm –-cached index.htm # 스테이지 삭제
```

테이지의 캐시 목록에서 파일이 삭제됩니다. 

다시 status 명령어를 실행하여 확인합시다.

```sh
$ git status
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        index.html
        track_file

nothing added to commit but untracked files present (use "git add" to track)
```

등록하기 이전의 untracked 상태로 변경되었습니다. 

다음 실습에 대비하여 다시 `tracked` 상태로 변경해 놓습니다.

```sh
$ git add index.html
```

파일을 등록한 후 커밋하지 않고 바로 삭제하려면 rm --cached 명령어를 사용합니다. 

하지만 한 번이라도 커밋을 했다면 reset 명령어를 사용해야 합니다. 

리셋 방법은 뒤편에서 자세히 설명합니다.

> git rm

```sh
$ git add index.html
$ git commit -am first
$ git rm –cached index.htm
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        index.html
        track_file
```

파일이 untracked 상태가 되고, 스테이지 영역에서 파일이 삭제 처리됩니다. 

커밋 후 삭제는 파일이 삭제 또는 변화된 것으로 간주합니다.

따라서 커밋된 파일은 리셋으로 삭제한 후 정리해 주어야 합니다. 

다음은 간단한 리셋 후 정리하는 명령어를 사용한 예입니다.

그리고 다시 status 명령어로 확인하면 정상적으로 커밋이 정리되었습니다.

> git reset

```sh
$ git reset HEAD index.htm # 리셋 시도
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        track_file
```

이처럼 터미널에서 `unstage` 상태 및 `untracked` 상태로 변경하는 것은 복잡합니다. 

소스트리를 이용하면 스테이지 영역에 등록된 파일을 좀 더 쉽게 등록 취소할 수 있습니다. 

모두 스테이지에서 내리기와 선택 내용 스테이지에서 내리기를 사용하면 `untracked` 상태로 쉽게 변경할 수 있습니다.

#### 등록된 파일 이름이 변경되었을 때

작업 도중 파일 이름도 변경할 수 있습니다. 

하지만 파일 이름을 변경했다고 별도로 깃에 통보할 필요는 없습니다. 

깃은 똑똑해서 변경된 파일 이름을 자동으로 알고 있습니다.

리눅스나 macOS에서는 `mv` 명령어로 파일 이름을 변경할 수 있습니다. 

깃에서도 파일 이름을 변경할 때 `mv` 명령어를 사용합니다.

> git mv

```sh
$ git mv 파일이름 새파일이름
```

다음과 같이 index.htm 파일의 이름을 변경하고 상태를 확인해 보면 깃에서 변경된 파일을 계속 추적하는 것을 알 수 있습니다.

```sh
$ git mv index.htm home.htm # 파일 이름 변경
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        renamed:    index.html -> home.htm

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        .ipynb_checkpoints/
        track_file
```

다음과 같이 index.html 파일의 이름을 변경하고 상태를 확인해 보면 깃에서 변경된 파일을 계속 추적하는 것을 알 수 있습니다.

굳이 git mv 명령어를 사용하지 않고, 운영 체제의 mv 명령어를 사용해도 됩니다. 

깃의 git mv 명령어를 여러 단계의 명령으로 풀면 다음과 같습니다.

```sh
$ mv index.htm home.htm 
$ git rm index.htm 
$ git add home.htm
```

실제 확인해 보겠습니다.

```sh
$ mv index.html home.htm
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        deleted:    index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        home.htm
        track_file

no changes added to commit (use "git add" and/or "git commit -a")
$ git rm index.html
rm 'index.html'
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    index.html

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        home.htm
        track_file

$ git add home.htm 
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        renamed:    index.html -> home.htm

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        track_file
```

예에서 알 수 있듯이, 이름을 변경한다는 의미는 기존 파일을 삭제하고 새 파일을 다시 스테이지 영역에 등록하는 과정과 유사합니다. 

풀어 쓴 명령에서 이름을 변경한 후에는 `rm`과 `add` 명령어를 실행해야 한다는 사실을 잊지 마세요.

다음 실습을 위해 이전 이름으로 되돌려 놓습니다.

```sh
$ git mv home.htm index.html
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        track_file
```

### 첫 번째 커밋

워킹 디렉터리에 생성된 파일을 스테이지 영역으로 등록하는 과정을 알아보았습니다. 

지금까지 한 작업은 커밋의 준비 작업들입니다. 

이번에는 스테이지 영역에 등록된 파일들을 커밋해서 기록하는 과정을 알아보겠습니다.

#### HEAD

커밋을 학습하기 전에 `HEAD` 개념을 하나 더 알아봅시다. 

깃에는 `HEAD`라는 포인터 개념이 있습니다. 

`HEAD`는 커밋을 가리키는 묵시적 참조 포인터입니다.

![HEAD](https://github.com/kim0lil/skfactory.github.io/blob/master/sources/2022/05/27/page13/0065.png?raw=true)

### 커밋 확인

### 두 번째 커밋

### 메시지가 없는 빈 커밋

### 커밋 아이디

### 커밋 로그

### diff 명령어

### 정리