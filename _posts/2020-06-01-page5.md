---
title: 스프링 - Jaxb2Marshaller를 활용한 XML View처리
tags: SPRING5 SPRING 스프링 IoC XML Jaxb2Marshaller
key: Jaxb2Marshaller - XML View
---

# Jaxb2Marshaller

Jaxb2Marshaller는 Spring Framework 라이브러리이며 **org.springframework.oxm**의 하위 클래스입니다.

이번에는 Jaxb2Marshaller를 활용하여 restful 통신에 사용되는 Model(Object)를 XML로 변환하는 방법에 관하여 다루어 보도록 하겠습니다.

## pom.xml
 
먼저 pom.xml을 열어 아래 두 의존성을 등록 하도록 합니다.

{% highlight pom.xml %}
<dependencies>
    <!-- 스프링 라이브러리 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.2.6.RELEASE</version>
    </dependency>
    <!-- 스프링 oxm(xml) 라이브러리 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-oxm</artifactId>
        <version>5.2.6.RELEASE</version>
    </dependency>
</dependencies>
{% endhighlight %}

라이브러리 등록을 완료 하였다면 이제 패키지로 가서 자바 설정 파일을 하나 만들어 두도록 하겠습니다.

## ApplicationConfiguration

설정 파일명은 **ApplicationConfiguration** 로 생성하겠습니다.

{% highlight ApplicationCinfiguration.java %}
public class ApplicationConfiguration { }
{% endhighlight %}

설정파일이 생성 되었다면 이제 초기화(initializer) 클래스를 생성하도록 하겠습니다.

초기화 클래스는 **ApplicationInitializer** 로 생성한 다음 

스프링 이벤트 리스너인 **AbstractAnnotationConfigDispatcherServletInitializer**를 구현하여

이전 생성한 **ApplicationConfiguration**을 서블릿 설정 클래스와 **서블릿 매핑 정보("/")**를 등록합니다.

{% highlight ApplicationCinfiguration.java %}
public class ApplicationInitializer 
	extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return null;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		return new Class[] { ApplicationConfiguration.class };
	}

	@Override
	protected String[] getServletMappings() {
		return new String[] { "/" };
	}

}
{% endhighlight %}

## UserRepository와 User

이제 저장소(Repository)와 POJO클래스를 생성하겠습니다.

저장소는 **UserRepository** POJO 클래스로는 **User**로 생성하겠습니다.

{% highlight UserRepository.java && User.java %}
public class User { }
public class UserRepository { }
{% endhighlight %}

POJO클래스의 속성값을 추가하도록 하겠습니다.

속성값으로는 id, name, address 3항목을 추가한 다음 **setter**를 추가 하겠습니다.

{% highlight User Schema %}
public class User {

    public User(String id, String name, String address) {
		this.id = id;
		this.name = name;
		this.address = address;
	}
    
	public void setId(String id) {
		this.id = id;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setAddress(String address) {
		this.address = address;
	}

    private String id;
    private String name;
    private String address;
}
{% endhighlight %}

이제 저장소의 사용자를 등록하고 조회 하는 기능을 추가하겠습니다.

특정 사용자를 조회하기 위하여 **findUser**, 전체 사용자를 조회하기 위하여 **findUserList** 기능을 추가 하도록 하겠습니다.

{% highlight UserRepository.java %}
public class UserRepository {

	private Map<String, User> repository = new LinkedHashMap<String, User>();

	public User findUser(String id) {

		return repository.get(id);
	}
	
	public UserRepository findUserList() {

		return this;
	}
}
{% endhighlight %}

UserRepository의 초기 사용자를 등록 하겠습니다.

{% highlight UserRepository.java %}
public class UserRepository {
	
	public UserRepository() {
		User user1 = new User("admin", "관리자" , "서울 특별시 영등포구 여의도동");
		User user2 = new User("dev01", "사용자1", "전라남도 부안군 청수리");
		User user3 = new User("dev02", "사용자2", "대전광역시 이수군 기립동");
		User user4 = new User("dev03", "사용자3", "대구광역시 중구 동인동");
		
		this.repository.put("admin", user1);
		this.repository.put("dev01", user2);
		this.repository.put("dev02", user3);
		this.repository.put("dev03", user4);
	}

	public UserRepository findUserList() {

		return this;
	}
	
	public List<User> findUserList() {

		return new ArrayList<User>(repository.values());
	}

	private Map<String, User> repository = new LinkedHashMap<String, User>();
}
{% endhighlight %}

이제 준비는 끝났습니다.

Jaxb2Marshaller를 활용하여 model(Object)를 xml로 된 view로 반환하도록 처리해보겠습니다.

이제 ApplicationConfiguration로 돌아가서 **Jaxb2Marshaller**와 Jaxb2Marshaller을 사용한 **View** 그리고 View를 이어줄 **ViewResolver**를 등록 하도록 하겠습니다.

(BeanNameViewResolver를 사용하는 이유는 후에 컨트롤러에서 ViewResolver를 xmlView로 뷰를 매핑하기 위합입니다.)

또한 @ComponentScan을 사용하여 빈 스캐닝을 자동으로 하도록 처리합니다.
